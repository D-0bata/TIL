# スッキリわかるSQL入門
dokoQL: https://dokoql.jp/

## 第1章 はじめてのSQL
### データベースとは
- 狭義のデータベースは、検索、書き換え、分析などのデータ管理を目的として蓄積された様々な情報そのものを指す。
- 広義のデータベースは、狭義のデータベース（実態はファイル）＋データベース管理システム（DBMS:database management system）で構成される。

### リレーショナルデータベースとは
- 現在、分野を問わず普及しているのがリレーショナルデータベース（RDB）。
- RDBは複数のテーブルで構成されている（各テーブルには識別のための名前が付けられている）。
- 各テーブルは行と列で構成されている（行と列を指定することで、1つのデータを検索、書き換え、分析の対象とできる）。
- RDBのDBMSを特にRDBMS（relational DBMS）という。

### DBMSとは
- DBMSにはSQLクライアントが付属しており、SQL文を受け付けるとともにDBMSに送信する（そのため、プログラムの作成は不要）。

### データベースによるデータ処理
- 操作対象のRDB（家計簿テーブル）はdokoQLに格納されている。
- 家計簿テーブルの列は日付、費目、メモ、入金額、出金額で構成されている。

- 検索処理
  ```
  select 検索対象列1, 検索対象列2, ... 検索対象列n
    from 検索対象テーブル
  [where 条件式]
  ※全ての列を選択する場合は「*」で代用可能。
  ```
- 追加処理
  ```
  insert into 追加対象テーブル
  values (値1, 値2, ... 値n)
  ```
- 更新処理
  ```
  update 更新対象テーブル
     set 更新対象列 = 更新する値
  [where 条件式]
  ```
- 削除処理\
  **※条件式を記載しないと全件削除となるため注意！！**
  ```
  delete from 削除対象テーブル
  [where 条件式]
  ```



## 第2章 基本文法と4大命令
### SQLの基本ルール（読みやすいSQL文を書くためのルール）
- SQL文の整形（文の途中に改行や半角スペースを入れられる。下記SQLは同じ意味で、2の方が読みやすい。）
  ```
  1. select 列1, 列2 from テーブル where 条件式
  ``` 
  ```
  2. select 列1, 列2
       from テーブル
      where 条件式
  ```
- コメント
  1. --：「--」から行末までコメントとして扱われる。
  2. /\*\*/：「/\*」から「\*/」までコメントとして扱われる。複数行のコメントに対応可能。
- 予約語
  1. selectやwhereなどの命令に使う単語は特別な意味を持つため、テーブル名や列名などに使用できない。
  2. 予約語は大文字と小文字の区別がない（select、SELECT、Select、selECT、いずれも同じ）。

### リテラルとデータ型
- リテラル：SQL文の中に書き込まれた具体的なデータそのもの（123、'123'、'2025-10-01'など）\
  リテラルの記述に関するルール（データ型について）
    1. シングルクォーテーションで括られずに記述されたリテラルは数値情報として扱われる。\
      例：123は3桁の数字「ひゃくにじゅうさん」を表す。
    2. シングルクォーテーションで括られたリテラルは文字情報として扱われる。\
      例：'123'は3文字の文字列「いちにさん」を表す。
    3. シングルクォーテーションで括られ、かつ、下記のように一定の形式で記述されたリテラルは日付情報として扱われる。\
      例：'2025-10-01'は日付「2025年10月1日」を表す。

- データ型と列
  1. データベース内の表の各列は、名前の他に列に格納できるデータ型（data type）を定めている。\
    ※利用可能なデータ型はDBMSに依存するが、数値型、文字列型、日付と時刻の型は基本的に使用可能。\
    ただし、型の名称や型の取り扱い方は異なるため、より詳細な情報（特に日付）は必ず各DBMSのマニュアルを参照すること！
  2. 列には、データ型で指定された種類の情報のみ格納できる。\
    ※誤ったデータ形式で格納された場合の挙動はDBMSに依存する（処理を中断、強制的な型変換をして処理続行など）。
  
- 代表的なデータ型
  |データ種別 |  区分  | 代表的なデータ型名                                |
  |:--------|:------|:------------------------------------------------|
  |数値      |整数    |integer型、int型                                 |
  |         |小数    |decimal型、numeric型、float型、double型、real型    |
  |文字列    |固定長  |char型                                           |
  |         |可変長  |varchar型                                        |
  |日付と時刻 |-      |timestamp型、datetime型、date型、time型            |

    ※timestamp型は日付と時刻の両方を持つ。\
    ※char型：予め指定されたバイト数の領域が確保されており、不足分は空白で補われる。\
     varchar型：格納されたバイト数に合わせて領域が確保され、不足分は空白で補わない。\
     両型ともに、最大長が設定されているため、それを超えるバイト数は格納できない。

- SQLの命令\
  下記4つの命令（DML:Data Manipulation Language）でほとんどのデータ操作が実現可能。
  1. select
  2. update
  3. delete
  4. insert

  豊富な修飾語で複雑なデータ操作を実現する。
  |命令          |各命令固有部分                               |対象行の絞り込み |検索結果の加工|
  |:------------|:------------------------------------------|:-------------|:----------|
  |1. select    |列名 ... from テーブル名                     |where ~       |その他の修飾  |
  |2. update    |テーブル名 set 列名 = 値                     |where ~       |            |
  |3. delete    |from テーブル名                             |where ~       |            |
  |4. insert    |into テーブル名 (列名 ...) values (値 ...)   |              |            |

  ※列名に「*」を指定すると、全ての列を対象とできる（主にselect文で使用）。\
  **※where句の記述を忘れると全件対象（update文なら全件更新、delete文なら全件削除（0件のデータが格納された表）となる！**\
  ※列名やテーブル名に続けて「as 任意のキーワード」と記述することで、別名を定義できる（分かりやすい名前や略称を付けられる）。
  ```
  例：select 費目 as item, 入金額 as receive, 出金額 as pay 
       from 家計簿 as moneybook
  ```



## 第3章 操作する行の絞り込み
### where句と条件式
- where句の基本構文
  ```
  where 条件式
  ```

  ※条件式：演算結果が必ず真（true）か偽（false）になる式（正確には不明、計算不能(unknown)も存在する）\
   DBMSはデータベース内の表を1行ずつ条件を満たすか判定し、結果が**真の行に対してのみ**処理を行う。\
    => 結果的にwhere句に記述された条件を満たす行を絞り込める（false、unknownは対象外）。

- 条件式に用いる比較演算子
  |比較演算子 |意味                   |備考                    |
  |:--------|:----------------------|:----------------------|
  |=        |左辺と右辺の値が等しい     |                       |
  |<        |左辺は右辺より小さい      |                        |
  |\>       |左辺は右辺より大きい      |                        |
  |<=       |左辺は右辺の値以下        |※「=」を先にして記述しない！|
  |\>=      |左辺は右辺の値以上        |※「=」を先にして記述しない！|
  |<>       |左辺と右辺の値が等しくない |                        |

- NULLの判定\
  NULL：どのような値も格納されていない状態、値ですらない（数字の0、空白文字、長さ0の文字列のいずれとも異なる）
    1. 格納すべきデータが不明（unknown）
    2. データの格納対象外（N/A:not applicable）\
      従って、「値 <> NULL」のような比較は行えない（よくあるミス！比較演算子は値同士を比較するもので、NULLは値ではない！）。\
        => is null演算子：NULLであることを判定\
        => is not null演算子：NULLでないことを判定
        ```
        例：select * from テーブル
            where 列1 is [not] NULL
        ```
- 論理演算子（優先度：not > and > or、丸括弧で括ることで優先度を引き上げることが可能。）
  1. and演算子（基本構文：条件式1 and 条件式2）=> where句に複数の条件式の組み合わせを記述可能にする（2つの条件式が両方とも真なら真）。
  2. or演算子（基本構文：条件式1 or 条件式2）=> where句に複数の条件式の組み合わせを記述可能にする（2つの条件式いずれかが真なら真）。
  3. not演算子（基本構文：not 条件式）=> where句の条件式の真偽を逆転させる。

- その他の演算子
  1. like演算子（基本構文：式 like パターン文字列）=> where句にパターンマッチングによる検索条件を記述可能にする。\
    like演算子に使えるパターン文字

      |パターン文字      |意味                |
      |:---------------|:------------------|
      |%               |任意の0文字以上の文字列|
      |_（アンダースコア）|任意の1文字          |

      ```
      例：select * from 家計簿
          where メモ like '%10月%' 
      ```
      
      ※「%」は0文字以上の任意の文字列を意味するため、「'%10月%'」は「10月」を含む文字列を意味する。\
      ※「%10月」は「10月」で終わる文字列を意味し、「10月_」は「10月」で始まり、後ろに任意の1文字が続く文字列を意味する。
      
      問題：「%」や「_」を含む文字列をパターンマッチする場合は...?\
        => escape句を併用し、エスケープ文字を指定する。
      ```
      例：select * from 家計簿 where メモ like '%100$%' escape '$'
      ```

  2. between演算子（基本構文：式 between 値1 and 値2）=> where句に「値1以上値2以下」による検索条件を記述可能にする。
  3. in/not in演算子（基本構文：式 \[not\] in (値1, 値2, 値3 ...)）\
    => where句で複数の値との比較を記述可能にする（値リストのそれぞれと比較して、いずれかが真なら真）。
  4. any演算子（基本構文：式 基本比較演算子 any (値1, 値2, 値3 ...)）\
    => where句で複数の値との比較を記述可能にする（値リストのそれぞれと比較して、いずれかが真なら真）。
  5. all演算子（基本構文：式 基本比較演算子 all (値1, 値2, 値3 ...)）\
    => where句で複数の値との比較を記述可能にする（値リストのそれぞれと比較して、全て真なら真）。

### 主キー（primary key）
-主キーとなる列が持つべき特性
  1. NULLでないこと（必ず何らかのデータが格納されること）。
  2. 一意に識別できる値であること（他の行と値が重複しないこと）。
  3. 一度決めた値は変化しないこと。
  ※主キーがない場合、行を一意に特定できず（重複行の発生）、where句での絞り込みができなくなってしまう。

- 主キーの作り方
  1. 自然キー（natural key）：表に既にある主キーの役割を果たすことのできる列を使用する。
  2. 人工キー（artificial key）、代替キー（surrogate key）：管理目的のための列を人為的に追加する（<=>自然キー）。
  3. 複合主キー（composite key）：複数の列を1つの主キーとして使用する。

- キーの種類
  1. スーパキー：表中の行を一意に特定できる属性、あるいは属性の組のこと\
    （極端な例：表内に同一行がなければスーパキーに全ての属性を指定可能）。
  2. 候補キー：スーパキーの中で余分な属性を含まない、行の特定に必要な最低限の属性で構成されるスーパキーのこと。\
    2-1. 主キー：候補キーのうち、任意に選んだ1つの候補キーのこと。\
    2-2. 代理キー（alternative key）：主キーに選ばれなかった残りの候補キーのこと。\
    **※代理キー（alternative key）は代替キーとも呼ばれるが、代替キー（surrogate key）とは意味も概念も異なるため注意！！！**\
    日本語訳が偶然重複しただけ。



## 第4章 検索結果の加工
### select文の修飾による検索結果の加工
- select文の2段階の処理
  1. 通常の検索実行
  2. 検索結果を加工
- 検索結果を加工する主なキーワード

  |キーワード      |内容                                    |
  |:-------------|:--------------------------------------|
  |distinct      |検索結果から重複行を除外する。               |
  |order by      |検索結果の順序を並べ替える。                |
  |offset - fetch|検索結果から件数を限定して取得する。          |
  |union         |検索結果に他の検索結果を足し合わせる。        |
  |except        |検索結果から他の検索結果を差し引く。          |
  |intersect     |検索結果と他の検索結果で重複する部分を取得する。|
  
  ※検索結果の加工はDBMS内部で並び替えの実行が伴う可能性がある。\
  並び替えはDBMSにとって負荷の大きい処理である（性能上のボトルネックとなることを防ぐため、インデックスなどを導入する）。

- distinct：重複行の除外（データの種類を取得したいときなどに使用）
  ```
  select distinct 列名 ...
    from テーブル名
  ```

- order by：検索結果の並べ替え（指定しないと順序保証はされない。select文の結果が実質ランダムに表示されるようになる。）\
  **select文の最後に指定すること！！！**
  ```
  select 列名1, 列名2, ... from テーブル名
   order by 列名1 並び順, 列名2 並び順
  ```
  ※並び順：「asc」または「desc」を指定する（省略するとascがデフォルトで指定される）。\
  ※order by句に指定した列名ごとに並び順が指定できる（列名1について昇順で並び替え、その結果を列名2について降順に並び替えるなど）。\
  ※列名は数字で指定することも可能（最も左の列が **「1」** ！！！）
  ```
    select * ... from テーブル名
     order by 1 並び順, 2 並び順
  ```
  ※数字による列名指定はunionなどの集合演算子を用いる場合に使用するが、頻度は低い\
  （集合演算子を用いると単純な列名指定が使用できないため）。

- offset - fetch：行数を限定して取得（通常order by句と併用される）
  ```
  select 列名 ... from テーブル名
   order by 列名 ...
  offset 先頭から除外する行数 rows
   fetch next 取得行数 rows only
  ```
  ※先頭から取得したい場合は先頭から除外する行数は0に指定する。\
  ※MySQL、MariaDB（10.6未満）、SQLiteではサポートされない。

- union：和集合
  ```
  select文1
  union [all]
  select文2
  [order by 列番号 ...]
  ```
  ※「all」を付けると重複行をまとめずに全てそのまま表示する。付けないと重複行を1つにまとめる。\
  ※両select文で選択列リストの列数とそれぞれのデータ型が一致している必要がある。\
  逆に、列数とデータ型が一致していれば格納データが全く異なるものでも集合演算できる。\
  ※order by句は **最後の** selectb文に記述する。\
  ※列番号以外（列名やasによる別名）で並べ替えるには、 **1つ目の** select文に記述した列名を指定する。

- except：差集合
  ```
  select文1
  except [all]
  select文2
  [order by 列番号 ...]
  ```
  ※select文1と2の順番が入れ替わると結果も異なる（先に記述したselect文から後に記述したselect文の内容を削除する）。

- intersect：積集合
  ```
  select文1
  intersect [all]
  select文2
  [order by 列番号 ...]
  ```


## 第5章 式と関数
### 計算式と演算子について
- 選択列リスト中の計算式と固定値の扱い\
  列名：列の内容がそのまま出力される。\
  計算式：計算式の評価結果が出力される（「列1+100」とすると、100加算された列1が得られる）。\
  固定値：固定値（リテラル）がそのまま出力される。
- 列1+100の計算は各行ごとに行われる。

- DBMSがサポートする演算子
  1. 加減乗除（+、-、*、/の4種類。+と-は日付の計算にも使用可能。）
  2. ||（文字列の連結を行う。DBMSによっては＋演算子を用いる。）
  3. case演算子\
    3-1 case演算子の構文1
      ```
      case 評価列または条件式 when 値1 then 値1のときの戻り値
                          [when 値2 then 値2のときの戻り値]
                          [else デフォルトの戻り値]
           end
      ```
      ```
      例：select 費目, 出金額,
           case 費目 when '居住費' then '固定費'
                    when '水道光熱費' then '固定費'
                    else '変動費'
            end as 出費の分類
           from 家計簿 where 出金額 > 0
      ```
      3-2 case演算子の構文2
      ```
      case when 条件1 then 条件1のときの戻り値
          [when 条件2 then 条件2のときの戻り値]
          [else デフォルトの戻り値]
       end
      ```
      ```
      例：select 費目, 入金額,
           case when 入金額 < 5000 then 'お小遣い'
                when 入金額 < 100000 then '一時収入'
                when 入金額 < 300000 then '給料出た！'
                else '想定外の収入です！'
            end as 収入の分類
           from 家計簿 where 入金額 > 0
      ```

### 関数
- 引数（入力）=> 関数（定められた処理）=> 戻り値（出力）：関数は入力値の変換装置

- 関数の呼び出し：関数名(引数...)\
  例：length(文字列) => 文字列長
- 入れ子の関数は内部から処理される。\
  例：length(trim('SQL  ')) => length('SQL') => 3

- 関数も計算式と同様に、表の各行に対して、1行1行処理を行う。

- 関数はDBMSごとに違いが大きく、互換性が少ないので、詳細は各DBMSのマニュアルを参照すること。
- 関数はユーザー定義関数として自分で作成することができる。
- 複数の関数処理を1つにまとめて外部から呼び出せるようにしたものをストアドプロシージャという。\
  ストアドプロシージャのサポート言語はDBMSにより異なるが、専用言語やC言語、Javaなどで記述される。

### 文字列にまつわる関数
- length/len：文字列長の取得\
  length(文字列) => 文字列長（文字列数またはバイト数（DBMSに依存））\
  len(文字列) => 文字列長（文字列数またはバイト数（DBMSに依存））

- trim/rtrim/ltrim：空白文字の削除\
  trim(文字列) => 左右から空白を削除した文字列\
  rtrim(文字列) => 右から空白を削除した文字列\
  ltrim(文字列) => 左から空白を削除した文字列\
  ※char(10)の列に対して「abc」を格納すると、「abc+半角スペース7つ」の形で格納される。\
   select文を実行すると半角スペース付きで取得してしまうため、trim関数を用いて不要な半角スペースを除去する。

- replace：指定文字を置換\
  replace(置換対象文字列, 置換前の部分文字列, 置換後の部分文字列) => 置換処理された文字列

- substring/sub strstr：文字列の一部を抽出\
  substring(文字列, 抽出開始位置, 抽出文字数) => 抽出された部分文字列\
  substr(文字列, 抽出開始位置, 抽出文字数) => 抽出された部分文字列\
  ※抽出文字数の省略で文字列の最後までを対象とできる場合もある。\
  ※位置や数は文字数またはバイト数で指定する（DBMSに依存）。

- concat：文字列を連結（連結可能な文字列の数やNULLの扱いはDBMS依存）\
  concat(文字列1, 文字列2[, 文字列n...]) => 連結後の文字列\
  **※通常の文字列の連結は＋演算子や||演算子を使用する。**\
  ※SQL ServerやMySQLなどでは3つ以上の文字列の指定が可能。\
  ※1つでもNULLの文字列があるとNULLを返すDBMSもある。

- 関数はDBMSに対して複雑な処理を指示できるが、負荷の増大によるパフォーマンスの低下には注意が必要。\
  例：複数の関数を複雑に組み合わせた場合、関数利用によりインデックス検索が無効化された場合など。

### 数値にまつわる関数
- round：指定桁で四捨五入\
  round(数値を表す列, 有効桁数) => 四捨五入した値\
  ※「有効桁数」に指定する値が正の場合は小数部の桁数、負数の場合は整数部の桁数を表す。

- trunc：指定桁で切り捨て\
  trunc(数値を表す列, 有効桁数) => 切り捨てた値\
  ※「有効桁数」に指定する値が正の場合は小数部の桁数、負数の場合は整数部の桁数を表す。

- power：冪乗を計算\
  power(数値を表す列, 何乗するか指定する数値) => 指定回数だけ乗じた結果

### 日付にまつわる関数
- current_timestamp => 現在の日時（年、月、日、時、分、秒）
- current_date => 現在の日付（年、月、日）
- current_time => 現在の時刻（時、分、秒）\
  ※関数名の後ろに()は不要。

### 変換にまつわる関数
- cast：データ型を変換\
  cast(変換する値 as 変換する型) => 変換後の値
- coalesce：最初に登場するNULLでない値を取得\
  coalesce(列または式1, 列または式2, 列または式3...) => 引数のうち、最初に現れたNULLでない引数\
  ※任意の数の引数を指定できる。ただし、全ての引数の型を一致させる必要がある。\
  ※もし全ての引数がNULLの場合、戻り値はNULLになる。\
  ※Oracle DBとDb2では、NULLに限定して別の値に置き換えるNVL関数もよく使用される。



## 第6章 集計とグループ化
### 集計関数
- select文で集計関数を用いると、検索結果は該当する行ではなく、該当する行の集計結果となる\
  第5章の関数：検索結果の各行に対して処理を行う（結果表の行は増減しない）\
  集計関数：集計対象となった全ての行に対して1回だけ計算を行い、1つの答えを出す（結果表は必ず1行になる）\
    例：select sum(列) from テーブル => 1行の集計結果

### 代表的な集計関数（詳細は各DBMSのマニュアルを参照のこと）
- sum：各行の値の合計を求める（sum(列) => 合計）
- max：各行の値の最大値を求める（max(列) => 最大値）
- min：各行の値の最小値を求める（min(列) => 最小値）
- avg：各行の値の平均値を求める（avg(列) => 平均値）
- count：行数をカウントする
  1. count(列) => 検索結果の指定列に関する行数 ... 指定列がNULLである行を無視してカウントする
  2. count(*) => 検索結果の行数             ... 単純に行数をカウントする（NULLの行も数に含める）


- 重複した値を除いた集計\
  select count(distinct 列) from テーブル => 対象列に格納されているデータの種類をカウントする

### 集計関数に関する注意点4つ
- select文でしか使用できない（そもそも集計関数は「検索結果」に対して集計を行うための道具）
  ```
    select 列      集計関数の記述：OK
      from テーブル
     where 条件式
  order by ~       集計関数の記述：OK
    having ~       集計関数の記述：OK
  ```
- 結果表が凸凹になってはならない（結果表の行数は全て同じであること）\
  ```
  select 列1,      => 通常の検索なので、複数行になる
         sum(列2)  => 集計関数の結果なので、1行になる => 結果表の列によって行数が異なってしまう（エラー！）
    from テーブル
  ```

- 対応する引数の型が異なる

  |関数名  |数値型       |文字列型              |日付や時刻型  |
  |:------|:-----------|:--------------------|:-----------|
  |sum    |各数値の合計  |NG                   |NG          |
  |max    |各数値の最大  |並び替えて最後の文字列  |最も新しい日時 |
  |min    |各数値の最小  |並び替えて最初の文字列  |最も古い日時   |
  |avg    |各数値の平均  |NG                   |NG          |
  |count  |行数         |行数                 |行数         |

- NULLの扱い
  
  |関数名  |           |集計時のNULLの扱い                 |全行がNULLの場合の集計結果|
  |:------|:----------|:--------------------------------|:---------------------|
  |sum    |           |無視（NULLは集計に影響を与えない）    |NULL                  |
  |max    |           |同上                              |同上                  |
  |min    |           |同上                              |同上                  |
  |avg    |           |同上                              |同上                  |
  |count  |列名指定行数 |無視（NULLは集計に影響を与えない）    |0                     |
  |       |*指定       |NULLを含んでカウントする            |当該行数               |

  ※NULLを0に読み替えて集計をしたい場合はcoalesce関数を使用する。\
  select avg(coalesce(列, 0)) from テーブル

### データをグループに分割する
- グループ化（group by）：\
「集計の前に」指定した基準で検索結果をいくつかのまとまりに分ける操作\
（集計はグループ毎に実行され、グループ毎の集計結果が結果表の各行に対応する）
  ```
      select グループ化の基準列1, グループ化の基準列2, ... ,集計関数
        from テーブル
       where 条件式
    group by グループ化の基準列1, グループ化の基準列2, ...
  ```

  ※上記SQL文の実行順序
  1. where句：通常の検索処理
  2. group by句：指定列中の同じ値ごとに行を分類
  3. 各グループに対して集計関数の処理を実行、結果表を出力\
  ※複数列によるグループ化を実行した場合（例えば、列1と列2をグループ化の基準とした場合）、\
   列1の値と一致する、かつ、列2の値と一致する行をグループとする（グループ内で列1と列2の値は全て同じになる）。

- 集計結果の絞り込み（having）\
  問題：集計結果から集計に不要な行を取り除けない（必要な行のみに絞り込めない）。\
       SQL文の実行順序は下記の通りである。(1)のwhere句実行の時点では(3)で実行される集計関数がまだ実行されていないため、\
       不定である。従って、where句には集計関数を記述することができず、集計に必要な行だけの絞り込みができない。
  1. where句：通常の検索処理
  2. group by句：指定列中の同じ値ごとに行を分類
  3. 各グループに対して集計関数の処理を実行、結果表を出力
  
  対策1：where句に集計関数を使用しない。条件式によって不要な行を予め除去しておく。\
  **対策2：(4)having句により、集計結果「後」に絞り込みを行う。**
  ```
    select グループ化の基準列1, グループ化の基準列2, ... ,集計関数
      from テーブル
     where 条件式
  group by グループ化の基準列1, グループ化の基準列2, ...
    having 集計結果に対する絞り込み条件
  ```

- select文の基本構文（まとめ）
  ```
     select 選択列リスト
       from テーブル
     [where 条件式]
  [group by グループ化の基準列リスト]
    [having 集計結果に対する条件式]
  [order by 並び替え列]             **※order by句は必ず最後に記述すること！！**
  ```

  **※select文でグループ集計を行う場合、選択列リストに指定する列は下記の条件いずれかを満たす必要がある。**\
  1. **group by句にグループ化の基準列として指定されている。**
  2. **集計関数による集計の対象となっている。**

### 集計テーブル
- 集計テーブル：あるテーブルの集計結果を格納するために作成した別のテーブル
  1. 作成：集計関数による集計処理を1回実行し、集計テーブルに登録
  2. 使用：既存の集計テーブルに格納された、計算済み結果を読込（速い！！）

- 集計テーブルの更新：\
集計テーブルに格納されている内容は最新のデータを用いた集計より古いリスクがある（定期的に集計処理を実行し直す必要がある）。\
更新作業は必須。



## 第7章 副問い合わせ
### 副問い合わせ：あるSQLの結果を別のSQL文に組み込むことで複雑な処理を実現する方法
- 例1：2回のselectが必要な場合 => select文のネスト
  ```
  select 列1, 列2 from テーブル1
  where 条件式 = (select max(列1) from テーブル1)
  ```
  1. 丸括弧内のSQL文が実行される（副問い合わせ、副照会、サブクエリという）。
  2. 1の結果をwhere句の条件式に組み込み、2つ目のSQL文を実行する。

- 例2：2つの副問い合わせ
  ```
  update ... (select ... )
  where  ... (select ... )
  ```

- 例3：副問い合わせの中に副問い合わせ
  ```
  update ... (select ...
                (select ... ))
  ```

### 副問い合わせのパターン
- 副問い合わせの結果が1行1列（単一の値）になるパターン
- 副問い合わせの結果がn行1列（複数の値）になるパターン
- 副問い合わせの結果がn行m列（表の値）になるパターン

- データ構造の種類
  単一の値           ：スカラー
  1次元に並んだ値、配列：ベクター
  2次元に並んだ値、表 ：マトリックス
    副問い合わせの3パターンは、検索結果がそれぞれスカラー、ベクター、マトリックスになると考えることができる。

### 単一行副問い合わせ
- 検索結果が1行1列の1つの値となる副問い合わせを指す。
- select文の選択列リストやfrom句、update文のset句、1つの値との判定を行うwhere句の条件式などに記述できる。

- set句での使用例
  update 家計簿集計
     set 平均 = (select avg(出金額)
                  from 家計簿アーカイブ
                 where 出金額 > 0
                   and 費目 = '食費')
   where 費目 = '食費'
  
  (1)家計簿アーカイブテーブルから食費に関する出費の平均額を求める。
  (2)家計簿集計テーブルの食費欄の平均を(1)の値で更新する。
    => 集計テーブルの更新処理を副問い合わせで実現した。

- 選択列リストで使用する
  select 日付, メモ, 出金額
         (select 合計 from 家計簿集計
           where 費目 = '食費') as 過去の合計額
    from 家計簿アーカイブ
   where 費目 = '食費'

  (1)家計簿集計テーブルから食費の合計を検索し、過去の合計額列の固定値として設定する。
  (2)家計簿アーカイブテーブルから食費に関する出費の日付、内容、出金額、合計額を出力する。
    => 食費の各明細と、これまでの食費の合計を同時表示を副問い合わせで実現した。

### 複数行副問い合わせ
- 検索結果がn行1列（複数の行からなる単一列、複数の値）となる副問い合わせを指す。
- 複数の値との判定を行うwhere句の条件式や、select文のfrom句に記述できる。
- in/not in、any/all演算子を用いた条件式中で記述できる。単一の値の代わりに記述はできない。
  （例：select ... where 列1 < (select ...) => 副問い合わせの結果が複数の値になるためエラー！！）

- in演算子での使用例
  in演算子を用いた条件式（第3章参照）
    select * from 家計簿集計
     where 費目 in ('食費', '水道光熱費', '教養娯楽費', '給料')

  副問い合わせによる置き換え
    select * from 家計簿集計
     where 費目 in (select distinct 費目 from 家計簿)

- any/all演算子での使用例
  select * from 家計簿
   where 費目 = '食費'
     and 出金額 < any (select 出金額 from 家計簿アーカイブ where 費目 = '食費')
    =>食費に関わる出費について、家計簿アーカイブテーブルに記録された金額未満のものを家計簿テーブルから検索する。

- 副問い合わせにおけるNULLの取り扱いについての注意
  問題：下記のSQL文はnot in演算子にNULLを含むため結果は不定となる
       （NULLにはis null/in not null演算子を用いること！！（not in NULL => NULLでない => 不定でない => 不定））。
       **データベースを用いたアプリケーションで陥りやすいミスのため、特に注意！！**
    select * from テーブル
     where 列1 not in ('値1', '値2', NULL)
    
    =>では、副問い合わせの結果がNULLとなってしまった場合は...？
  
  対策：(1)副問い合わせの絞り込み条件にis not null条件を含める。
       (2)coalesce関数を用いてNULLを別の値に置換する。
    
       (1)select * from テーブル1
           where 列1 not in (select 列1 from テーブル2 where 列1 is not null)
    
       (2)select * from テーブル1
           where 列1 in (select coalesce(列1, '不明') from テーブル2)

### 表副問い合わせ
- 検索結果がn行m列の表となる副問い合わせを指す。
- select文のfrom句やinsert文などに記述できる。

- from句での使用例
  select sum(sub.出金額) as 出金額合計
    from (select 日付, 費目, 出金額 from 家計簿 union
          select 日付, 費目, 出金額 from 家計簿アーカイブ
           where 日付 >= '2024-01-01' and 日付 <= '2024-01-31') as sub
  => 家計簿アーカイブから1月の出費に関するデータを、家計簿テーブルから今月（2月）の出費に関するデータを取得し、結合する。
     結合した表から出金額の合計を計算し、出力する。

- intert文での使用例
  insert into 家計簿集計(費目, 合計, 平均, 回数)
  select 費目, sum(出金額), avg（出金額）, 0    ※
    from 家計簿
   where 出金額 > 0
   group by 費目
  
  => 副問い合わせにより、1回のinsert文で複数行のデータ登録が可能となる。
  **※丸括弧なしの副問い合わせはinsert文だけの特例（正確には副問い合わせではなく、insert文の特殊構文）である。**
  **副問い合わせ部分はvalues以降の記述に相当する。**
  ※副問い合わせの結果表の列と登録するテーブルの列が完全に一致していれば、insert into 家計簿集計 select ...と記載可能。



## 第8章 複数テーブルの結合
### 複数のテーブルを繋げる仕組み（外部キーとリレーションシップ）
- リレーションシップ：ある2つのテーブル間にある情報の関連のこと。
- 外部キー：ある列に格納された値で、別表の関連行を一意に特定するために機能する。
         また、外部キーの値は別表の主キーの値である（よって、重複が発生せず、関連行が一意に特定される）。

- 複数テーブルにデータを分割するメリット：データを安全、確実、高速に取り扱いできる。
  例1：格納データを変更する場合
    単一テーブル => 100,000行あったらその中から対象行を全て探して変更する必要がある（100,000ループ）
    複数テーブル => 表1（100,000行）と表2（表1から外部キーで参照されている表）があったとき、
                  表2を1行変更するだけでよい（最大で表2の行数分ループ << 100,000行）
  
  例2：格納データに関する補足情報を管理したい場合
    単一テーブル => 1つの表に同じデータが多数格納される。
    複数テーブル => 表1と表2（表1から外部キーで参照されている表）があったとき、
                  表2の1行だけにデータが格納されている
                  （1箇所で管理されているため、追加、変更、削除が容易、データベースに矛盾が発生しない）。   

- 複数テーブルにデータを格納するデメリット：人間にとって複数テーブルに分割されていると見にくい。
  =>管理に適した複数テーブルを、（人間が見るときだけ）人間が理解しやすい単一テーブルに変換する（join）

  **このような機能を持つデータベースを「RDB」といい、中枢を担うDBMSをRDBMSという。**
  **RDBはデータを複数テーブルに分割して管理することで、安全、確実、高速に処理するとともに、**
  **表の結合によって、人間にとって理解しやすい表を提供する。**

### テーブルの結合
- 2つのテーブルの結合
  select 選択列リスト
    from テーブル1
    join テーブル2
      on 両テーブルの結合条件
  
  例：家計簿テーブルに費目テーブルの内容を結合する処理
    select 日付, 名前 as 費目, メモ.    ※名前列は家計簿テーブルにないが、join句で結合されるため、参照可能になる。
      from 家計簿
      join 費目                       ※結合する他の表を指定する。
        on 家計簿.費目ID = 費目.費目ID  ※結合条件を指定する。
    
    (1)join句、on句が実行され、2つのテーブルが結合する。
    (2)select文によって行と列が絞り込みされる。

### 結合条件のルール
- 内部結合（inner join）
  結合相手が複数行の場合（左表のある1行について、右表で対応する行が複数見つかる）
    =>右表で見つかった行数に応じて、左表の1行がコピーされる。 **従って、結果表はもとの左表の行数よりも増える。**
      左表のn行目        => 右表のm1行目
      左表のn行目のコピー => 右表のm2行目

  結合相手の行がない場合
    =>右表に結合相手の行がない場合、左表の結合条件の列がNULLの場合、結合結果から消滅する。
      **従って、結果表はもとの左表の行数よりも減る。**
      左表のn行目        => 右表に対応行なし           => 消滅
      左表のn行目（NULL） => 右表で対応行が見つけられない => 消滅

      => 右表に対応行が見つからないからといって勝手に行を消滅させてもらっては困る...

- 左外部結合（left outer join）：左表については、結合相手が見つからない、あるいは、
                              左表の結合条件列がNULLであっても必ず出力させる。
  select ... from 左表
        left join 右表
               on 結合条件
  ※left joinはleft outer joinとも記述できる。
  ※結合相手が見つからない、または、左表の結合条件列がNULLの場合、結果表に抽出される右表の列は全てNULLとなる。

- 右外部結合（right outer join）：右表の全ての行を必ず出力する。
  select ... from 左表
       right join 右表
               on 結合条件
  ※right joinはright outer joinとも記述できる。

- 完全外部結合（full outer join）：左右の表の全ての行を必ず出力する。
  select ... from 左表
        full join 右表
               on 結合条件
  ※full joinはfull outer joinとも記述できる。
  ※DBMSによっては完全外部結合がサポートされていないため、「左外部結合 union 右外部結合」で完全外部結合を実行する。

### 結合に関する様々な構文
- テーブル名の指定：結合する2つのテーブルに同じ名称の列があるときは、
                「テーブル名.列名」と記述し、どのテーブルに属するかを明示する。
  
  例1：
  select 日付, 家計簿.メモ, 費目.メモ
    from 家計簿
    join 費目
      on 家計簿.費目ID = 費目.ID
  
  例2：テーブルに別名をつけた場合のSQL文
  select 日付, K.メモ, H.メモ
    from 家計簿 as K
    join 費目 as H
      on K.費目ID = H.ID

- 3テーブル以上の結合：join onを繰り返せば3つ以上のテーブルを結合することも可能。
  select 日付, 費目.名前, 経費区分.名称
    from 家計簿
    join 費目
      on 家計簿.費目ID = 費目.ID
    join 経費区分
      on 費目.経費区分ID = 経費区分.ID
  
- 副問い合わせの結果との結合： **選択列リストでの列名指定や結合条件指定のため、副問い合わせに別名が必須！！**
  select 日付, 費目.名前, 費目.経費区分ID
    from 家計簿
    join (select * from 費目
          where 経費区分ID = 1
    ) as 費目
      on 家計簿.費目ID = 費目.ID

- 同じテーブル同士の結合：自己結合（self join）または再帰結合（recursive join）ともいう。
                     **選択列リストでの列名指定や結合条件の指定のため、同じテーブルに異なる別名が必須！！**
       select A.日付, A.メモ, A.関連日付, B.メモ
         from 家計簿 as A
    left join 家計簿 as B
           on A.関連日付 = B.日付

- 非等価結合（non-equi join）： **動作原理は通常の結合と同じだが、DBMSに大きな負荷がかかる点に注意！！**
  select ... from テーブル1
    join テーブル2 on テーブル1.列1 < テーブル2.列2



## 第9章 トランザクション
### トランザクション（transaction, TX）：複数のSQL文を一塊にまとめたもの
- トランザクションのルール
  1. トランザクションの途中で、処理が中断されないようにする。
  2. トランザクションの途中で、他の人が割り込みできないようにする。
    => DBMSが一塊のSQL文を扱うことをトランザクション制御（transaction control）という。

### コミットとロールバック：トランザクションの途中で、処理が中断されないようにする。
- DBMSはトランザクションを「一部だけが実行される状況はあってはならない、途中で分割不可能なもの」として扱う。\
    => 両方実行されているか、両方実行されていないかの2パターンになるようにコントロールする。\
    => **原子性（atomicity）と呼ばれる性質。**\
    例：銀行の送金処理（送金元での残高減のupdate文と、送金先での残高増のupdate文）

- 問題：原子性はどのように実装されている？
  1. コミット：トランザクションが正常終了して、更新を確定する行為（コミット前までの変更は仮の状態として扱われる）
  2. ロールバック：トランザクションが異常終了して、更新をキャンセルする行為

- トランザクションの作成方法
  1. begin：開始の指示、以降のSQL文を1つのトランザクションとする。
  2. commit：終了の指示、ここまでを1つのトランザクションとし、確定する。
  3. rollback：終了の指示、ここまでを1つのトランザクションとし、取消する。\
    ※Oracle DBやDb2などでは支持しなくてもトランザクションは自動で開始されるため、beginは使用しない。
    ```
    例：家計簿の1月分データをアーカイブファイルへ移動する。
    begin;
    
    -- 処理1：アーカイブファイルへコピー
    insert into 家計簿アーカイブ
    select * from 家計簿 where 日付 <= '2024-01-31';

    -- 処理2：家計簿テーブルから削除
    delete from 家計簿 where 日付 <= '2024-01-31';

    commit;
    ```
    ※処理1実行直後に障害が発生した場合、自動的にロールバックが行われ、処理1の実行は取り消される。\
    また、最後の行にcommitではなく、rollbackと記述すると処理1と2の両方が（正常に）取り消される。

- 自動コミットモードの解除\
  問題：通常、DBMSはデフォルト状態で自動コミットモードで動作し、1つのSQL文ごとに裏で自動的にコミットを実行してしまう。\
    **=> そのため、データの削除などの操作がrollbackで戻せない場合がある！！！**

  対策：「begin」を明示的に実行することで、自動コミットモードを一時的に解除する。\
    ※他にも自動コミットモードを解除する方法があるので、詳細は各DBMSのマニュアルを参照すること。

### トランザクションの分離：トランザクションの途中で、他の人が割り込みできないようにする。
- 同時処理による3つの副作用
  1. ダーティーリード（dirty read）：コミットされていない仮の状態を他の人が読み込むこと。
    => 更新確定か取消か未確定な情報をもとにして別の処理を行う危険な処理！
  2. 反復不能読み取り（non-repeatable read）：表の内容を複数回読み込む際、途中でデータ内容が更新されてしまうこと。
    => 処理1の集計結果と処理2の集計結果で不整合が発生するなど。
  3. ファントムリード（phantom read）：2に類似した副作用。2回のselect文の間に他の人がinsert文で行を追加すると、\
    1回目と2回目のselect文で行数が変化してしまうこと。
    => 1回目の検索結果の行数に依存する処理を行うと問題が発生する。
  
  対策：トランザクションを用いる。
    => DBMSは個々のトランザクションの **分離性（isolation）** と呼ばれる性質を維持するようにコントロールを行う。\
      分離性：同時実行された場合と、それぞれ単独で実行された場合とで、結果が同じになる性質。
    => **ロック（lock）：あるトランザクションが完了するまで他のトランザクションを待機させる（処理速度は低下する）。** 

- トランザクションの分離レベル
  ロックを使用すると安全だが、処理速度が低下する（二律背反）...？
    => トランザクション分離レベル（transaction isolation level）：どの程度厳密にトランザクションを分離するか設定可能。

    |分離レベル        |1. ダーティーリード|2. 反復不能読み取り|3. ファントムリード|               |
    |:---------------|:---------------:|:--------------:|:---------------:|:------------:|
    |read uncommitted|恐れあり           |恐れあり         |恐れあり          |高速、危険      |
    |read committed  |発生しない         |恐れあり         |恐れあり           |↑             |
    |repeatable read |発生しない         |発生しない        |恐れあり          |↓             |
    |serializable    |発生しない         |発生しない        |発生しない        |低速、安全      |
    ※大抵の場合はread committedを選択しておけば大丈夫。
  
  トランザクション分離レベルの指定
  ```
  set transaction isolation level 分離レベル名  
  ```
  もしくは
  ```
  set current isolation 分離レベル名
  ```
  ※どちらの構文をつかいうかはDBMSによって異なる。

- MVCC（multi-version concurrency control）：\
  あるデータについて、「書き換え済み（ただし未確定）」と「書き換え前」の2バージョン併存させること。\
    => あるトランザクションによってデータ更新中であっても「書き換え前」の情報が残っており、他のトランザクションから利用可能\
      （ロックなしでダーティーリードを防止できる）。\
    => Oracle DBやPostgreSQLには分離レベルとしてread uncommittedがないものもある\
      （コミットしてないものは読ませないというルール）。

### ロック
- SQL文により指定した対象（いつ、どこ）を明示的にロックできる（通常はDBMSが自動的に行にロックをかける）。
  明示的なロックの種類
  1. 行ロック：ある特定の行だけをロックする。
  2. 表ロック：ある特定のテーブル全体をロックする。
  3. データベースロック：データベース全体をロックする。\
  ※データベースによっては「ページ」や「表スペース」などもロックの対象となる。

  ロックの強さ
  1. 排他ロック（exclusive lock）：主に更新時に利用。他からのロックを一切許容しない。
  2. 共有ロック（shared lock）：主に読取じにしよう。他からの共有ロックは許容する。

- 行ロックの取得：select ~ for update\
  select文の末尾に「for update」を追加することにより「排他ロック」を明示的に記述できる。\
  ※通常はselect文で選択した行には自動的に「共有ロック」がかけられる。
  ```
  select ~ for update [nowait]
  ```
  ※nowaitオプションを指定した場合はロックの解除を待機せずに、すぐにロック失敗のエラーを返し、トランザクションは即時終了する。\
   処理を待たせたくないアプリケーションなどに有効。
  
  例：ロックによる集計
  ```
  begin;
  select * from 家計簿
   where 日付 >= '2024-02-01'
     for update                ※2月以降のデータを明示的にロック。

  -- 集計処理1
  select ~ ;

  -- 集計処理2
  select ~ ;

  -- 集計処理3
  select ~ ;

  commit;                      ※ロックが解除される。
  ```

- 表ロックの取得：lock table
  ある特定の表全体をロックするには、lock table命令を用いる。

  明示的な表ロックの取得
  ```
  lock table テーブル名　in モード名 mode [nowait]
  ```
  ※モード名は「exclusive」で排他ロック、「share」で共有ロックとなる。

  例：ロックによる集計
  ```
  begin;
  lock table 家計簿 in exclusive mode; ※表を明示的にロック。

  -- 集計処理1
  select ~ ;

  -- 集計処理2
  select ~ ;

  -- 集計処理3
  select ~ ;

  commit;                             ※ロックが解除される。
  ```
  **※ロックは最小限に！！！**\
  **明示的にロックする時は、必要最小限の範囲に留める。**\
  **排他ロックの代わりに共有ロックを使用できないか検討する。**

- デッドロック（dead lock）
  1. 資源XをロックしたトランザクションAが、次に資源Yもロックしようとしている。その一方で...。
  2. 資源YをロックしたトランザクションBが、次に資源Xもロックしようとしている。
  
  問題：処理が永久に止まる。\
  ※ただし、多くのDBMSはデッドロックの自動解決機構が備わっている（片方のトランザクションを強制的に失敗させる）。\
   => 少なくとも1つのトランザクションが失敗し、再実行のための無駄な時間が発生する。\
   => デッドロックの発生は可能な限り避けるべき。
  
  対策（予防）：
    1. トランザクションの時間を短くしてデッドロック発生確率を下げる。
    2. 行やテーブルを同じ順番でロックする。



## 第10章 テーブルの作成
### 4種類のSQL命令

|大分類|小分類                             |命令                            |説明                                   |
|:----|:---------------------------------|:------------------------------|:--------------------------------------|
|1    |DML（Data Manipulation Language）  |select、insert、update、delete、|データの格納や取り出し、更新、削除などの命令  |
|     |                                  |explain、lock table            |                                       |
|     |TCL（Transaction Control Language）|commit、rollback、             |トランザクションの開始や終了の命令           |
|     |                                  |set transaction、savepoint     |                                       |
|2    |DDL（Data Definition Language）    |create、alter、drop、truncate  |テーブルなどの作成や削除、各種設定などの命令   |
|     |DCL（Data Control Language）       |grant、revoke                  |DMLやDDLの利用に関する許可や禁止を設定する命令|
  1. データベースにデータの出し入れを指示する命令
  2. テーブルの準備や権限などの設定を指示する命令 \
  ※DBMSによって各命令の分類が異なることがある。

- DCLとは？\
  誰にどのようなデータ操作やテーブル操作を許可するかといった権限を設定するためのSQL命令の総称。
  1. grant文：権限を付与する。
      ```
      grant 権限名 to ユーザー名
      ```
  2. revoke文：権限を剥奪する。
      ```
      revoke 権限名 from ユーザー名
      ```
  ※上記の命令はデータベース全権を管理するデータベース管理者（DBA：Database Administrator）だけが使う命令である。

### テーブルの作成
- create table文：テーブル作成用のDDL\
  ※同じ名前のテーブルを作成するとエラーになる。
  ```
  create table テーブル名 (
    列名1 列1の型,
    列名2 列2の型,
    :
    列名n 列nの型
  )
  ```

  例：これまでの家計簿テーブル
  ```
  create table 家計簿 (
    日付   date,
    費目ID integer,
    メモ   varchar(10),
    入金額 integer,
    出金額 integer
  )
  ```

- デフォルト値の指定（列に対する設定）
  insert文で具体的な値を指定していない列に、NULLではなくデフォルト値を格納できると便利だが...？
  => 「defaultキーワード」
  ```
  create table テーブル名 (
    列名1 列1の型 default デフォルト値,
    :
  )
  ```

  例：デフォルト値付きの家計簿テーブル
  ```
  create table 家計簿 (
    日付   date,
    費目ID integer,
    メモ   varchar(10) default '不明',
    入金額 integer      default 0,
    出金額 integer      default 0
  )
  ```

- テーブルの削除
  ```
  drop table テーブル名
  ```
  ※「delete from テーブル名」はテーブルの中身を削除する命令で、入れ物の表自体は削除されない。\
  ※DBMSによってはDDLが取り消せない場合がある。例えば、Oracle DBでは基本的にDDLはロールバックできず、取り消しができない。\
   そのため、重要な操作の前にはバックアップを取り、安全に配慮する必要がある。

- テーブルの更新：具体的にテーブルの「何を」「どう」変更するのかを指定する必要がある。\
  列の追加
  ```
  alter table テーブル名 add 列名 型
  ```
  
  列の削除
  ```
  alter table テーブル名 drop 列名
  ```

- DBMSによってはテーブルの存在を確認してから作成/削除する機能がある。
  ```
  -- 存在しない時のみテーブルを作成
  create table if not exists テーブル名 ( ... );
  
  -- 存在する時のみテーブルを削除
  drop table if exists テーブル名;
  ```

### 制約
- SQLの文法が正しければ、DBMSに対して誤った操作ができてしまう。
  => 人為的ミスに対してはトランザクション制御は機能しない。
- DBMSは「制約（constrain）」によって、データ型よりもさらに強力で細かい制限をかけ、データベースを安全に保つことができる。
  
  制約の指定を含むテーブルの作成
  ```
  create table テーブル名 (
    列名  型　[default デフォルト値] 制約の指定,
    :
  )
  ```
  ※複数の制約を指定する場合は「,」ではなく、半角スペースで区切る。

- 広く普及しているDBMSでは主に5種類の制約がサポートされている。
- 基本的な3つの制約
  1. not null
    nullの格納を許可しない。default指定と組み合わせて利用されるのが一般的（エラー回避のため）。
  2. check
    ある列に格納される値が妥当か細かく判定する。丸括弧内に記述した条件式が真の場合のみ格納を許可する。
  3. unique
    ある列の内容が重複することを許可しない。nullの重複は許容される（nullは比較対象にすらなり得ないため、重複と判定されない）。

  例：基本的な3つの制約を伴う家計簿
  ```
  create table 家計簿 (
    日付   date        not null,
    費目ID integer,
    メモ   varchar(10) default '不明' not null,
    入金額 integer      default 0 check(入金額 >= 0),
    出金額 integer      default 0 check(出金額 >= 0)
  );

  create table 費目 (
      ID integer,
    名前  varchar(40) unique
  );
  ```

- 4.主キー制約（primary key制約）
  制約としては「unique制約」+「not null制約」に相当するが、それだけではなく主キーとして設定されている列という意味を与える。
  
  主キー制約の指定（単独列）
  ```
  create table 費目 (
      ID integer      primary key,
    名前  varchar(40)  unique
  )
  ```

  主キー制約の指定（複合主キー）
  ```
  create table 費目 (
      ID integer,
    名前  varchar(40)  unique,
    primary key(ID, 名前)
  )
  ```

- 5.外部キー制約（foreign key制約）
  参照整合性が崩れるようなデータ操作をしようとした場合にエラーを発生させ、強制的に処理を中断させる制約のこと。\
  参照元のテーブルの外部キー列に設定する。
  
  参照整合性（reference integrity）：外部キーが指し示す先にあるべき行が存在してリレーションシップが成立している状態のこと。
  参照整合性の崩壊：外部キーで別テーブルの行を参照しているのに、その行が存在しない状態のこと（絶対に避けること！！！）。

  崩壊の原因
  1. 「他の行から参照されている」行を削除してしまう。
  2. 「他の行から参照されている」行の主キーを変更してしまう。
  3. 「存在しない行を参照する」行を追加してしまう。
  4. 「存在しない行を参照する」行に更新してしまう。

  外部キー制約の指定1
  ```
  create table テーブル名 (
    列名 型 references 参照先テーブル名(参照先列名)
    :
  )
  ```

  外部キー制約の指定2
  ```
  create table テーブル名 (
    :
    foreign key (参照元列名)
     references 参照先テーブル名(参照先列名)
  )
  ```

  例：外部キー制約をしていした家計簿
  ```
  create table 家計簿 (
    日付   date        not null,
    費目ID integer     references 費目(ID),
    メモ   varchar(10) default '不明' not null,
    入金額 integer      default 0 check(入金額 >= 0),
    出金額 integer      default 0 check(出金額 >= 0)
  )
  ```

## 第11章 様々な支援機能
### データベースをより速くする
- インデックス(index)の作成と削除\
  インデックスの特徴
  1. インデックスは指定した列に対して作られる。
  2. インデックスが存在する列に対して検索が行われると、DBMSは自動的にインデックスの使用を試みるため高速になる場合が多い\
    （検索の内容によってはインデックスの利用ができず、性能が向上しない場合もある）。
  3. インデックスには名前を付けなければならない。

  インデックスの作成
  ```
  create index インデックス名 on テーブル名(列名)
  ```

  インデックスの削除
  ```
  drop index インデックス名
  ```
  ※SQL ServerやMySQL、MariaDBでは、「on テーブル名」を付ける。

- 高速化のパターン（常に高速化する訳ではない）
  1. whereによる絞り込み

      インデックス列をwhere句に指定（完全一致検索）
      ```
      select * from テーブル名
       where インデックスを作成した列名 = 値 
      ```

      インデックス列をwhere句に指定（前方一致検索）
      ```
      select * from テーブル名
       where インデックスを作成した列名 like '値%'
      ```
      ※部分一致検索や後方一致検索では通常インデックスは使用されないので注意

  2. order byによる並び替え

      インデックス列をorder byに指定
      ```
      select * from テーブル名
       order by インデックスを作成した列名
      ```

  3. joinによる結合の条件

      インデックス列をjoinの結合条件に指定
      ```
      select * from テーブル1
        join テーブル2
          on テーブル1.インデックス指定した列名 = テーブル2.列名
      ```
  => where、order by、joinの結合条件に頻繁に登場する列が存在するならば、インデックスの効果が得られやすい。

- インデックスの注意点（乱用は禁止）\
  インデックス作成のデメリット
  1. 索引情報を保存するために、ディスク容量を消費する。
  2. テーブルのデータが変更されるとインデックスも変更する必要があるため、\
     insert文、update文、delete文のオーバーヘッドが増える。

### データベースをより便利にする
- ビューの作成\
  ビュー：結果表をテーブルのように扱える機能のこと（例：家計簿テーブルから4月分だけ抽出したもの）。\
    => 同じようなSQL文を書かなくて良くなる。

  ビューの作成
  ```
  create view ビュー名 as select文
  ```

  ビューの削除
  ```
  drop view ビュー名
  ```

  例：4月の家計簿データのみを持つビューを定義
  ```
  create view 家計簿4月 as
  select * from 家計簿
   where 日付 >= '2024-04-01' and 日付 <= '2024-04-30'
  ```

- ビューのメリット
  1. シンプルで分かりやすいSQL文を書くことができる（上述の通り）。
  2. 権限と組み合わせて、データ参照を許可する範囲を柔軟に定めることができる\
    （テーブルAから秘密情報を除いたビューA’を作成し、テーブルAへのアクセス禁止、ビューA’へのアクセスは許可など）。

- ビューの制約とデメリット
  1. テーブルは自由にinsertやupdateができるが、ビューは通常select文しか実行できない。\
    => ビューは仮想的なテーブルで、実体は「名前の付いたselect文」なため（DBMSがviewを受け取ると、select文として展開する）。
  2. シンプルなSQL文に見えても実際は負荷の高い処理になる可能性がある。

- 重複しない番号の管理\
  採番：独自の番号を振るために、適切な番号を取得する作業\
    => 代表的な方法：連番（最後に使った番号を記録しておけば良い）\
    => 採番テーブル：既に採番した番号や最後に採番した番号を専用のテーブルに記録しておく
  
  問題：上記の方法では、新しい行の追加時に採番テーブルを必ず参照し、採番後は忘れずに更新する必要がある。\
       （逆に手間が増えているのでは...？）

  対策：DBMSの機能を使用する（実現方法は各DBMSによるので、マニュアルを確認すること）。
  1. 連番が自動的に振られる特殊な列を定義する\
    => create table文で列を定義する際に「連番を振る列である」と宣言する（各マニュアル参照）。
  2. 連番を管理してくれる専用のツールを使用する\
    => シーケンス（sequence）を利用する。シーケンスは採番した最新の値を常に記録しており、シーケンスに指示を出すことで\
       「最後に採番した値」や「次に採番するべき値」を取り出すことが可能。\
       ※ただし、シーケンスの値は取り出し後にすぐ確定し、変更できない（他のトランザクションから利用されることを考慮しているため）。

        シーケンスを作成する
        ```
        create sequence シーケンス名
        ```
        ※作成時にデフォルト値、最大値、増加値などのオプションを指定可能。

        シーケンスを削除する
        ```
        drop sequence シーケンス名
        ```

  3. その他\
    => DBMSによって、独自の採番機構を提供しているものがある。

### データベースをより安全に使う
- これまで学んだ安全機構
  1. コミット、ロールバック：途中で処理が中断しても、データが中途半端な状態にならない
  2. 型、制約：あらかじめ指定した種類や条件に従った値だけを格納する。
  3. 分離レベル、ロック：同時に実行している他の人の処理から副作用を受けない。

- ACID特性（上記の1~3に対応）
  1. 原子性（atomicity）
  2. 一貫性（consistency）
  3. 分離性（isolation）
  4. 永続性（durability）\
    => バックアップ（back up）

- バックアップの整合性
  1. オフラインバックアップ：DBMSを停止して行うバックアップ
  2. オンラインバックアップ：DBMSを稼働しながら行うバックアップ

- ログファイルのバックアップ\
  問題：バックアップは時間がかかるため、頻繁には行えない。最後のバックアップ後に故障が発生した場合はデータが消失してしまう...？\
  対策：ログファイルだけを高頻度でバックアップする（全体のバックアップは1日1回などの低頻度で行う）。\
    => バックアップを組み合わせる。
  
  ログファイル：それまでにデータベースを更新した全てのSQL文を指す。
  
  復旧手順（ロールフォワード）
  1. 最後に取得したデータベースのバックアップを復元する。
  2. ログに記録されているSQLのうち、最後のデータベースバックアップ以降に実行されたものを再実行する。

  ロールバック：実行した処理を取り消す。\
    => データベースの利用中に実行失敗やデッドロックなどを要因として度々発生する。
  ロールフォワード：まだ実行されていない処理を実行する。\
    => 障害復旧時に行われる処理であるため、滅多に発生しない。



## 第12章 テーブルの設計
### データベースを用いたシステム開発
- SQLやDBMSの機能に関する知識だけでは、データベースを用いたシステム開発はできない。\
  要件をしっかりと理解し、その要件をデータベース設計に落とし込むための方法を活用する必要がある。
- データベース設計の流れを整理すると、お客様の要件をインプットして、必要なテーブルを持つデータベースをアウトプットすること。\
  input：要件の一覧表（お客様から聴取したもの）\
  output：DDL一式（実行して必要十分なテーブルを生成する）
- 具体的な手順は？
  1. 概念設計：データベースやシステムのことは考えず、管理すべき情報はどのようなものなのかを整理する作業。
  2. 論理設計：1で明らかになった情報について、RDBを使う前提で構造を整理し、詳しく具体化する。\
             どんなテーブルを作り、どんな列を作るかを考える（型や制約、付随的な部分については考えない。）。
  3. 物理設計：特定のDBMSを使う前提に立ち、2で明らかになった各テーブルについて、型、インデックス、制約、デフォルト値など\
             テーブル作成に必要なすべての要素を確定させる。
### 概念設計
- 概念設計の構成要素
  1. エンティティ：テーブルのようなもの
  2. 属性：テーブルの列のようなもの
  3. 関連：リレーションシップのようなもの

- ER図（ERD：entity relationship diagram）
  1. ジェームズ。マーチンが考案したIE（Information Engineering）という形式や、
  2. アメリカ空軍が開発したIDEF1Xと呼ばれる形式などがある。

- ER図の記述ルール
  エンティティの名前\
  |--------------------------|\
  |主キー  　　　　　　　　　|\
  |--------------------------|\
  |属性　　　　　　　　　　|\
  |属性(FK)　　　　　　　　|※FK：外部キー\
  |:　　　　　　　　　　　　|\
  |--------------------------|

  多重度、カーディナリティー：エンティティ同士の数量的な関係を表す。
  1. ---------+-　1
  2. -------o-+-　0または1
  3. ---------<-　多
  4. -------o-<-　多（0以上）
  5. --------+<-　多（1以上）
  
- エンティティを導き出す手順
  1. 候補となる用語を洗い出す\
    1-1.要件の中から名詞を抜き出す。\
    1-2.要件が実現されている姿を仮定して、登場する「人」「物」「事実」「行為」などの用語を書き出す。
  2. 不要な用語を捨てる\
    2-1.他の用語の具体例でしかないものを捨てる（例：具体的な人名など）\
    2-2.計算や集計をすれば算出可能な値は捨てる。
  3. 関連がありそうなものをまとめる\
    3-1.同じ用語に関連するものを集める。
  4. エンティティ名と属性名に分ける\
    4-1.3でまとめたグループの中で、「〜をした〜」や「〜の〜」という表現が成り立つ場合、前者がエンティティ名に、後者が属性名になる。

- エンティティの中にエンティティは作らない（二重構造エンティティは作らない）
  二重構造は分割し、分離したエンティティの主キーを外部キー経由で結ぶ。

### 論理設計
- 概念上のエンティティをリレーショナルデータモデルで取り扱いやすい形のテーブルに変換する。\
  概念設計で作成したER図はあくまでも概念の世界における理想的なエンティティ構造を表しているに過ぎないため、\
  このままの状態でデータベースに格納できるとは限らない。 
- 論理設計の流れ\
  input：概念モデル\
  output：論理モデル

  1. 多対多の分解\
    => リレーショナルデータベースは多対多の関係をうまく扱えない。\
       （[]->o--------------o<-[]）\
    => 2つのエンティティの対応を格納した中間テーブル（連関エンティティ）を追加して多対多を2つの1対多に変換する。\
       （[]-+----o<-[]->o----+-[]）
  2. キーの整理\
    2-1.主キーを持たないエンティティには管理のための人工キーを追加する。\
    2-2.不適切な主キーを持つエンティティがないか確認する。

      主キーが備えるべき3つの特性\
      非NULL性：必ず何らかの値を持っていること。\
      一意性：他の値と重複がないこと。\
      普遍性：一度決定されたら値は変化しないこと。
  
  3. 正規化（normalization）\
    矛盾したデータを格納できないようにテーブルを複数に分割していく作業のこと。\
    => なぜ正規化をする？\
    3-1.内容に重複が多く、分かりにくい。\
    3-2.データ更新時には複数の関連箇所を正確に更新しなければならず、更新漏れ、誤りなどにより不整合が発生するため。

### 正規化：1つの事実は1箇所に（one-fact in one-place）
- 正規化の段階\
  第5正規化まで存在するが、一般的なシステム開発を目的とする場合は第3正規化までで足りる。\
  正規化によって表が適切に分割された状態を正規形（normalized form）という。\
  非正規形 => 第1正規形 => 第2正規形 => 第3正規形
  
- 第1正規化：「繰り返しの列」や「セルの結合」を排除する。
  1. 繰り返しの列の部分を別の表に切り出す。
  2. 切り出したテーブルの仮の主キーを決める。
  3. 主キー列をコピーして複合主キーを構成する。

- 第2正規化：非キー属性から部分関数従属を排除する。\
  関数従属性（functional dependency）：ある列Aの値が決まれば、自ずと列Bの値も決まるような関係のこと。\
  このとき、「列Bは列Aに関数従属している」という。 
  
  部分関数従属：複合主キーの一部に関数従属する関係を指す。\
  完全関数従属：複合主キーの全体に関数従属する関係を指す。

  1. 複合主キーの一部に関数従属する列を切り出す。
  2. 部分関数従属していた列をコピーする。

- 第3正規化：非キー属性間の関数従属を排除する。\
  推移的関数従属：主キーに対して間接的に関数従属している関係を指す（関数従属した属性に関数従属）。

  1. 間接的に主キーに関数従属する列を切り出す。
  2. 直接的に関数従属していた列をコピーする。

- トップダウンとボトムアップの統合\
  論理設計の重要な終了条件：システムに必要な全てのテーブルと列を漏れなく明らかにする。

  トップダウン・アプローチ（top down approach）：お客様の理想・要件を起点とする設計の流れ\
  ボトムアップ・アプローチ（bottom up approach）：お客様の今の現実を起点とする設計の流れ\
    => 実務上は、前者によるER図を基本にしつつ、後者によるER図から得られる情報を適切に取り込んで\
       新たな要件を満たしながら、見落としを防ぐ手法をとる。

### 物理設計
- 物理設計の流れ（使用するDBMSは既に決まっているとする）\
  input：論理モデル\
  output：物理モデル => DDL

  1. 物理名の決定\
    最終的なテーブル名、列名を決定する（通常はアルファベットを用いた名前を付ける）。\
    付けられる名前は物理名（physical name）という。論理設計まで使用してきた名前は論理名（logical name）という。
  2. 型・制約の決定\
    DBMSによって型の種類や数値の精度が異なるため、マニュアルなどを参照しながら最適な型を選択する。\
    DBMSによって制約の種類やデフォルト値が異なるため、マニュアルなどを参照しながら最適な型を選択する。
  3. インデックスの決定\
    DBMSの持つインデックスの特性やその列を利用する状況などを総合的に考慮して決定する。
  4. その他\
    利便性を考慮してビューを作成したり、性能のためにあえて正規化を崩したり、巨大なテーブルを分割したりする作業が行われることがある。
  
  以上の過程で確定した物理モデルは情報量が多く、ER図で表現できない仕様も含んでいる。\
  そのため、通常はER図とは別に「テーブル設計仕様書」などの名称で呼ばれる別文書に取りまとめられる。
